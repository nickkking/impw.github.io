---
title: R局部变量与全局变量
date: 2020-06-11 10:00:00
categories:
- 笔记
- 博客园
tags:
- 博客园
- 搬家
- cnblogs
---
# [这是👉R局部变量与全局变量👈的摘要](../../../../2020/06/11/cnblog_13094908/)
<!--more-->
在函数内部用赋值定义的变量都是局部变量， 即使在工作空间中有同名的变量， 此变量在函数内部被赋值时就变成了局部变量， 原来的全局变量不能被修改。
这种规则称为掩藏(masking)。 之所以如此， 是因为赋值本质上是“绑定”， 函数内部属于与工作空间（全局环境）不同的另一个环境，
一个变量一旦在函数内被重新绑定， 它就变成了仅在函数内部能被访问的变量， 即局部变量， 与原来在工作空间中同名的变量也没有关系了。
局部变量在函数运行结束后就会消失。 如 ``` if("x" %in% ls()) rm(x) f <\- function(){ x <\- 123
cat("函数内：x = ", x, "\n") } f() cat("函数运行完毕后：x=", x, "\n") ``` ## 函数内：x = 123 >
cat("函数运行完毕后：x=", x, "\n") ## Error in cat("函数运行完毕后：x=", x, "\n") : object "x"
not found 再比如， 下面的函数试图知道自己被调用了多少次， 但是因为每次函数调用完毕局部变量就消失，
再次调用时的局部变量已经对应到全新的存储空间， 所以如下的程序不能达到目的： ``` f <\- function(){
if(!exists("runTimes")){ runTimes <\- 1 } else { runTimes <\- runTimes + 1 }
print(runTimes) } f() ## [1] 1 f() ## [1] 1 ``` 虽然这个问题可以利用将调用次数保存在全局变量中解决，
但是应尽可能少用全局变量； 用R的闭包(closure)可以比较完美地解决这样的问题。 ##在函数内访问全局变量
函数内部可以读取全局变量的值，但一般不能修改全局变量的值。 在现代编程指导思想中， 全局变量容易造成不易察觉的错误， 应谨慎使用， 当然，也不是禁止使用，
有些应用中不使用全局变量会使得程序更复杂且低效。 在下面的例子中， 在命令行定义了全局变量x.g， 在函数f()读取了全局变量的值，
但是在函数内给这样的变量赋值， 结果得到的变量就变成了局部变量， 全局变量本身不被修改： ``` x.g <\- 9999 f <\-
function(x){ cat("函数内读取：全局变量 x.g = ", x.g, "\n") x.g <\- -1
cat("函数内对与全局变量同名的变量赋值： x.g = ", x.g, "\n") } f() ## 函数内读取：全局变量 x.g = 9999 ##
函数内对与全局变量同名的变量赋值： x.g = -1 cat("退出函数后原来的全局变量不变： x.g =", x.g, "\n") ##
退出函数后原来的全局变量不变： x.g = 9999 ``` 在函数内部如果要修改全局变量的值，用 <<-代替<-进行赋值。如 ``` x.g <\-
9999 f <\- function(x){ cat("函数内读取：全局变量 x.g = ", x.g, "\n") x.g <<\- -1
cat("函数内用"<<-"对全局变量变量赋值： x.g = ", x.g, "\n") } f() ## 函数内读取：全局变量 x.g = 9999 ##
对全局变量变量赋值： x.g = -1 cat("退出函数后原来的全局变量被修改了： x.g =", x.g, "\n") ##
退出函数后原来的全局变量被修改了： x.g = -1 ```


