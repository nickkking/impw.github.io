---
title: %
date: 2020-06-09 01:29:00
categories:
- 笔记
- 博客园
tags:
- 博客园
- 搬家
- cnblogs
---
# [这是👉%👈的摘要](../../../../2020/06/09/cnblog_13070518/)
<!--more-->
经常会有几个函数嵌套或者连续赋值几个临时变量时代码的可读性会很差，而管道操作符则解决这个问题 例如嵌套函数f(g(h(x))) 管道操作符为 ``` x
%>% h() %>% g() %>% f() %>% ``` 同时更加符合处理发生的次序 #一个稍复杂的例子 1.取10000个随机数，符合正态分布。
2.求这个10000个数的绝对值，同时乘以50。 3.把结果组成一个100*100列的方阵。 4.计算方阵中每行的均值，并四舍五入保留到整数。
5.把结果除以7求余数，并画出余数的直方图。 ##不使用管道操作符的两种代码 ###1 ``` # 设置随机种子 > set.seed(1) # 开始 >
n1<-rnorm(10000) # 第1步 > n2<-abs(n1)*50 # 第2步 > n3<-matrix(n2,ncol = 100) #
第3步 > n4<-round(rowMeans(n3)) # 第4步 > hist(n4%%7) # 第5步 ``` ###2 ``` >
set.seed(1) > hist(round(rowMeans(matrix(abs(rnorm(10000))*50,ncol=100)))%%7)
``` ###管道操作符 ``` # 设置随机种子 > set.seed(1) # 开始 > rnorm(10000) %>% \+ abs %>% `*`
(50) %>% \+ matrix(ncol=100) %>% \+ rowMeans %>% round %>% \+ `%%`(7) %>% hist
``` # %T%运算符 x %T% f()返回x本身而不是用f()修改后的返回值f(x)，
这在中间步骤需要显示或者绘图但是需要进一步对输入数据进行处理时有用。
%T>%左侧的数据集或函数结果（A）作为右侧程序（函数）的第一个参数调用，B（程序）函数的结果数据集**不再向右侧传递，而是把B左侧的A数据集**（或函数结果）再次向右传递给C函数（作为第一个参数调用），最后完成数据计算。
我们把上面的需求稍微进行调整，在最后增加一个要求，就会用到向左操作符。 1.取10000个随机数符合，符合正态分布。
2.求这个10000个数的绝对值，同时乘以50。 3.把结果组成一个100*100列的方阵。 4.计算方阵中每行的均值，并四舍五入保留到整数。
5.把结果除以7求余数，并话出余数的直方图。 6.对余数求和
由于输出直方图后，返回值为空，那么再继续管道，就会把空值向右进行传递，这样计算最后一步时就会出错。这时我们需求的是，把除以7的余数向右传递给最后一步求和，那么就可以用到
%T>% 了 直接使用%>%向右传值，出现异常。 ``` > set.seed(1) > rnorm(10000) %>% \+ abs %>% `*`
(50) %>% \+ matrix(ncol=100) %>% \+ rowMeans %>% round %>% \+ `%%`(7) %>% hist
%>% sum Error in sum(.) : invalid 'type' (list) of argument ``` 使用 %T>%
把左边的值，再向右传值，则结果正确。 ``` > rnorm(10000) %>% \+ abs %>% `*` (50) %>% \+
matrix(ncol=100) %>% \+ rowMeans %>% round %>% \+ `%%`(7) %T>% hist %>% sum
[1] 328 ```


